# 本稿の内容と参考文献
本稿は以下の資料をまとめるものである。

* 増永良文. 「データベース入門」. 2013年5月25日.
* Spivak, David I. “Functorial Data Migration.” arXiv, February 2, 2013. <https://doi.org/10.48550/arXiv.1009.1166>.
* Spivak, David I. “Category Theory for Scientists (Old Version).” arXiv, September 18, 2013. <https://doi.org/10.48550/arXiv.1302.6946>.

> 疑問点や考察に関しては、このようにMarkdownの引用の形式を用いる。

# データベースとは何か

## データベース

データベース：
現実世界に起こった現象・事象について、
データモデル（現実世界の出来事を記述するための何らかの記号系）によって機械可読な形でコンピュータに格納し、
様々なユーザの問い合わせやデータ処理に提供できるようにしたもの。

## データモデル・データモデリング

一般に、データモデルは以下の3つの要素からなる。

* 構造記述：データベースの構成要素の記述。２章で扱う
* 意味記述：リレーションだけでは補えない実世界の制約や、一貫性のための制約を扱う。３章でみる。
* 操作記述：検索・更新のためのデータ操作言語

データモデリング：現実世界をデータベース化する過程

データモデルを世に出た順番に分けると、概ね以下のものがある。

1. ネットワークデータモデル，ハイアラキカルデータモデル
    * ネットワークモデル：
        * レコード型と親子集合の２つによって、データやデータ間の関連を表す
        * データはレコード型に格納され、ポインタや鎖を用いて関連付ける
    * ハイアラキカルデータモデル：ネットワークモデルの特殊な場合
        * レコード：親レコードから子レコードに向けてレコードが張られる
1. リレーショナルデータモデル：全てのデータを、票として表現
1. オブジェクト指向データモデル：複合オブジェクトの表現に向いている。

リレーショナルデータモデル・オブジェクト指向データモデルについては、今後見ていく。

### データベースとファイルの違い
データベースとファイルの管理方法の違い

* データベース：データが複数個所に散在せず、無矛盾に保ちやすい
* ファイル：データがプログラムごとに管理され、データ間に矛盾が生じたりする。


## データベース管理システム

**データベース管理システム**（DataBase Management System）：
以下の３つの機能を持ったもの

1. **メタデータ管理機能**：「データのデータ」を管理
    * メタデータとは：２つの意味がある
        * 「どの様なデータが、どの様に格納されているか」についての情報。
        * DBMSそのものに関するデータ。データの種類やサイズ，付与されているindex，アクセス権等についての情報。
1. **質問処理機能**：データベースに対する質問(query)を処理する機能。
    * 特にRDBMSでは、SQL言語を用いて非手続き的・宣言的に書き下される。
    * 手続き的なファイルアクセスレベルのコードに変換する仕事がシステムの優劣を支配する。
1. **トランザクション管理機能**：データベースの一貫性を保持するための機能
    * **トランザクション**：DBMSに対するアプリケーションレベルの仕事の単位。
    * トランザクションの概念を堅持することで、２つの機能を全うする。
        * 障害児回復
        * 同時実行制御
    * トランザクションの処理に異常をきたす原因：
        * トランザクション自体の不備：プログラムエラー
        * システム障害：電源断
        * メディア障害：ディスククラッシュなど
    * 例えば、障害によってトランザクションが中途半端に更新したままの場合は、データベースのデータを旧値に戻す。


## コラム

データと情報：

* データ：記号の集まり
* 情報：データの受け手がデータを解釈し、得られた意味が受け手の持つ知識を増加した場合に情報が得らえる。


# リレーショナルデータモデル：構造記述

## リレーション

### 概念の定義

#### ドメインとその直積

**ドメイン**と呼ばれる集合がある。

ドメインの例：

* 集合
  * 有限集合
  * 無限集合
* データ型（で既定される集合）
  * 整数：INTEGER
  * 最大長10の可変長漢字列型：NCHARVARYING(10)

添え字集合を$I$とする。
$n$個のドメインを表現する際、添え字集合に$I=\{1,2,\cdots,n\}$を用いて$D_1, D_2, \cdots, D_n$と記述する習慣がある。

ドメインの定義の例：

* $D_1 = \{x|xは人名\}$
* $D_2 = \rm{NCHAR VARYNG(10)}$ （便宜的な表現）

$n$個のドメイン$D_1, D_2, \cdots, D_n$の直積$D$を以下で定義する。
$$ D = D_1 \times D_2 \times \cdots \times D_n $$

#### リレーションの定義

$D_1, D_2, \cdots, D_n$上の**リレーション**$R$を、
$$ R \subset D_1 \times D_2 \times \cdots \times D_n $$
と定義する。

リレーション$R$の定義より、**全ての要素はタプルで表現できる**。
このことからリレーションは集合ではあるが、**リレーションをテーブルとして表現できる**。
リレーションはドメインの直積から定義されていることから、カラムの順番（またはドメイン$D_i$の添え字$i$の順番）には意味がある。
一方リレーションがデータの集合であるため、行の並び順は情報を担っていない。
> テーブルで表現するには、「リレーションが可算集合」という条件が必要そう？

リレーション$R$に関連する定義：

* 濃度・基数 $|R|$：$R$のタプルの総数
* 次数 $n$：定義されているドメインの個数
* $n$項リレーション：次数が$n$のリレーション

### 例：リレーション

リレーションを以下のように定義してみる。

* $D_1 = \{x|xは人名\}$
* $D_2 = \rm{INTEGER}$
* $R \subset D_1 \times D_2$
* $R = \{ (太朗, 25), (一郎, 25), (花子, 25), (桃子, 25) \}$

これを表で表した場合の一例を挙げる。
|1|2|
|:-:|:-:|
|太朗|25|
|一朗|25|
|花子|25|
|桃子|25|


### リレーション名と属性名によるリレーションの定義
上記の表を挙げただけでは「何のデータであるか」についての解釈が一意的に定まらず、情報としては不足している。

実はリレーションを設計した時点でデータをどのように解釈すべきかは決まっている。
（実際には「何を観測したデータであるか」という情報を持ったうえで記号系にデータに変換している。しかし上記の方法でリレーションを定義すると、「何のデータであるか」という情報が抜けてしまう。）
このままでは設計者の意図を伝えられない。


そこでリレーション$R$に対して**リレーション名**を与え、さらに以下を定義する。

* 属性名$A_i \, (i=1,\cdots,n)$
* ドメイン関数 $\rm{dom}:A_i \mapsto D_i \quad (i=1,\cdots,n)$

これは各ドメインを指定する添え字集合$I$に、自然数の集合$\{1,\cdots,n\}$ではなく属性名$\{A_i\}_{i\in\{1,\cdots,n\}}$を用いることに等しい。
つまり以下のような表現をすること等価である。
$$D_i = D_{A_i} \quad (i=1,\cdots,n)$$

これらを用いて、リレーション$R$を次のように再定義できる。
$$R \subseteq dom(A_1) \times dom(A_2) \times \cdots \times dom(A_n)$$

$$R(A_1, A_2, \cdots, A_n)$$
こうすることでカラムの並び順の意味がなくなっている事に注意する。

#### 例：属性名・リレーション名

上記の例にリレーションリレーション名「友人」を与えれば、属性名とリレーションを以下のように定義する。

* $\rm{dom}(名前) = D_1$
* $\rm{dom}(年齢) = D_2$
* $友人 \subseteq \rm{dom}(名前) \times \rm{dom}(年齢)$

これを表で表すと、以下のように記述できる。

|名前|年齢|
|:-:|:-:|
|太朗|25|
|一朗|25|
|花子|25|
|桃子|25|





## リレーションスキーマ

リレーションスキーマ：時間に不変なリレーションの性質。

インスタンス：多くの場合、時間の移り変わりとともに変化するリレーションそのものを指す。

> リレーションを定義するためのドメイン直積をリレーションスキーマと呼んでいる？
> 時間的に変化することを強調するときに、リレーションをスキーマと呼んでいる？

## 第一正規系

ユーザフレンドリや質問の処理系の単純化のため、リレーションのドメインに対して制約を設ける。

第１正規系（ther first normal form, 1NF）：
$$\lnot \exist i \in I \;\; \exist \{D_\lambda\}_{\lambda\in\Lambda} \quad |\{D_\lambda\}_{\lambda\in\Lambda}| \neq 1 \Rightarrow D_i = \prod_{\lambda\in\Lambda} D_\lambda $$
つまりリレーションの中にリレーションが含まれるような、入れ子型リレーションにならないような制約になっている。
> 要確認：数式

> PostgreSQLのpoint型は非第１正規系？

### 非第１正規形と正規化

ドメインに直積を持つような入れ子型リレーション（内部にリレーションを含むリレーション）や，
ドメインが冪集合であるようなケース（つまり要素として集合をもつドメイン）は、
非第１正規形と呼ばれる。
これを正規化する例を見ていく。

#### ドメインが直積である場合：姓と名からなる名前

平民苗字許容令（1870年），平民苗字必称令（1875年）の公布をきっかけに、現在でも多くの日本人の名前は姓と名の２つに分けられる。
リレーションの属性に人名を持つ場合、非第１正規形に注意する必要がある。

例えば属性名「名前」のドメインが$\rm{dom}(名前) = \rm{dom}(姓) \times \rm{dom}(名)$
と定義されているリレーション
$$R\subset\rm{dom}(名前)$$
は、次のようなテーブルで表せる。
|名前|
|:-:|
|$(斎藤,太朗)$|

これを第１正規形にするには、リレーションを次のように定義する。
$$R \subset \rm{dom}(姓) \times \rm{dom}(名)$$
|姓|名|
|:-:|:-:|
|斎藤|太朗|

#### ドメインが冪集合である場合：複数の趣味を持つ人

複数の

例えば、斎藤太郎が趣味に野球・盆栽・コイン収集を持っている場合、

|姓|名|趣味|
|:-:|:-:|:-:|
|斎藤|太朗|{野球, 盆栽, コイン収集}|

と定義されているリレーションは、属性名「趣味」のドメイン$\rm{dom}(趣味)$が冪集合になってしまっている。

これを第１正規形化したリレーション
$$R \subset \rm{dom}(姓) \times \rm{dom}(名) \times \rm{dom}(趣味)$$
は、表にすると次の様に表現できる。

|姓|名|趣味|
|:-:|:-:|:-:|
|斎藤|太朗|野球|
|斎藤|太朗|盆栽|
|斎藤|太朗|コイン収集|





# リレーショナルデータモデル：意味記述

## キー制約

リレーショナルデータベースではデータベースを検索・更新をするいずれの場合にも、
リレーションのどのタプルにアクセスしようとするかを的確に指定する必要がある。

リレーションは集合として定義されているため、要素は一意的である（重複が無い）。
一般には、「リレーションの全属性の集合」の部分集合がタプルの一意識別能力を持つ。

**候補キー**：リレーション$R$上の属性のうち、一意識別能力を持つような最小の集まり。

### 主キー

属性名$A_i$が**主キー制約**と呼ばれる以下の条件を満たすとき、**主キー**と呼ばれる：

1. $A_i$はタプルの一意識別能力を備えている：候補キーである条件
    <br> $$\forall x,y \in \rm{dom}(A_i) \;\; x \neq y$$
1. $A_i$の属性は、空値をとらない：
    <br> $$\rm{null} \notin \rm{dom}(A_i)$$

### 外部キー

リレーション$R(\cdots,A_i,\cdots)$の属性$A_i$が**外部キー制約**と呼ばれる以下の条件を満たすとき、
リレーション$S(B_1,\cdots)$に関する**外部キー**であるという。

* $t[A_i], u[B_1]$を、それぞれ $t \in R, u \in S$ の$A_i$値と$B_1$値を表す。
* $\forall t \in R \;\; t[A_i] \neq \phi \Rightarrow (\exist u \in S \; t[A_i] = u[B_1])$


## 圏的スキーマとインスタンス

ここでは属性間・リレーション間の不変な関係を図示する圏的スキーマ(categorical scheme)を定義し、それを基にリレーションを作成するインスタンスを定義する。

### 準備

#### グラフと経路

グラフ$G=(V,A,s,t)$：

1. $V$は集合。
2. $A$は集合。
3. $s : A \to V$は関数。
4. $t : A \to V$は関数。

グラフ$G$上の長さ$n$の経路 $p \in \rm{Path}_G^{(n)}$：
$$ p = (v_0 \xrightarrow{a_1} v_1 \xrightarrow{a_2} v_2 \xrightarrow{a_3} \cdots  \xrightarrow{a_n} v_n)$$

ここで、$\rm{Path}_G^{(0)}=V$，$\rm{Path}_G^{(1)}=A$と定める。

> グラフ$G$上の長さ$n$の経路の集合 $\rm{Path}_G^{(n)}$は、fiber積$\times_V := \times_{s,V,t}$を使って定義できそう：
> $$\rm{Path}_G^{(n)} = \underbrace{A \times_V A \times_V \cdots \times_V A}_{n個のAの積}$$
> この時、経路$p$と矢$a$を合成した経路$ap, pa$が直積として自然に定義できる。

グラフ$G$上の全ての経路の集合：
$$\rm{Path}_G := \bigcup_{n \in \bb{N}} \rm{Path}_G^{(n)}$$

#### 経路同値

グラフ$G$とその経路$\rm{Path}_G$が与えられたとき、経路に対する同値関係を定義する。
ここでは $p,q \in \rm{Path}_G$，$m,n \in A$ とする。

path equivalence declaration (PED) $\sim$ : $p \sim q \overset{\text{def}}{\Longleftrightarrow} (s(p)=s(q) \land t(p)=t(q))$

経路$\rm{Path}_G$上のcategorical path equivalence relation (CPER) $\simeq$：

1. $p,q : a\to b \land m : z \to a$ のとき、$p \sim q \rArr mp \sim mq$
1. $p,q : a\to b \land n : b \to c$ のとき、$p \sim q \rArr pn \sim qn$

補題：$(p \simeq q : u \to v) \land (r \simeq s : v \to w) \rArr pr \simeq qs$

### 圏的スキーマ

グラフ$G$とCPER $\simeq$ の組を（圏的）**スキーマ**(categorical scheme) $\cal{C}$ と呼ぶ：$\cal{C} := (G, \simeq) .$
> $V$が対象の集合，$\rm{Path}_G$を射の集合，経路の結合を射の合成と見なし、図式の可換性を同値関係であるCPER$\simeq$とすれば、単位射$1_v:v \to v \; (v \in V)$を定義することでスキーマは圏になる。

本節では単にスキーマと呼が、後に実世界を記述するためにリレーションスキーマ，データベーススキーマを定義する。

### インスタンス

スキーマ$\cal{C}$上の**インスタンス**$I=(PK,FK) : \cal{C} \to \bf{\rm{Set}}$：

1. $PK : V \to \bf{Set}$（全ての$v \in V$に対し、$I(v)$は集合である。）
2. $\forall a : v \to w \in A, \quad FK(a) : PK(v) \to PK(w)$
3. $p,q : v \to w \in \rm{Path}_G, \quad p=(a_i)_{i=1,\cdots,n}, q=(b_i)_{i=1,\cdots,m}$とする。
    $$
    p \simeq q \quad \hArr
        \quad
    FK(a_n) \circ \cdots \circ FK(a_1) = FK(b_m) \circ \cdots \circ FK(b_1)
    $$

> スキーマを圏と見なした時、インスタンスは関手と見なせる。

インスタンスの定義とリレーションとの関係を以下に記す：

1. $PK(v)$はリレーション名$v$のリレーションにおける主キーに対応。
2. $a : v \to v' \in A, \; PK(a):PK(v) \to PK(v')$はリレーションを定義する際のドメインの直積に対応。
3. 他のリレーションの値を用いる場合、外部キーに対応する属性を用いてリレーションを定義しても本質的な問題はない。

また、以下が成立する：

* スキーマを対象に，スキーマの変換を射とすれば、スキーマの圏$\rm{\bf{Sch}}$が定義できる。
* 任意のスキーマ$\cal{C}$に対し、スキーマを対象，自然変換を射とすれば、$\cal{C}$上のインスタンスの圏$\cal{C}-\rm{\bf{Inst}}$が定義できる。
* $\rm{\bf{Sch}} \simeq \rm{\bf{Cat}}$：圏同値

> 今後、圏論と一緒に掘り下げたい。

### 例：圏的スキーマ

圏的スキーマの具体例をみるなら、["Category Theory for Scientists (Old Version)"(Spivak, David I. 2013. p.110~112)](https://doi.org/10.48550/arXiv.1302.6946)を参考にするとよい。
> 今後書くかも？

同文献のp.109. Example 3.5.2.15では、文章構造から自然にスキーマを定義出来ている点は面白い。
> ＊この例では、文章がSVO文型だからうまくいっているのかもしれない。どの様な表現であればスキーマが定義できるのか、日本語の場合でも適用できるのかについて注意が必要かも？

またp.110. Exercise 3.5.3.2では図式だけでなく、言語によって一貫性制約を記述することでデータベーススキーマになっている様に思える。

## その他の制約

一貫性制約（integrity constraint）：データベースが実世界の状態と矛盾せず、一貫していることを保証するための制約。

キー制約以外に、以下の項目がある。

* この章で紹介する制約：検査制約，表明，トリガ
* 正規化理論の章で扱う制約：関数従属性，多値従属性

### 検査制約(check constraint)

１つのリレーション内で適切な関係を保証するための制約を、**検査制約**という。
設計者の視点からの制約記述。

例：

* 社員の所属する部署の値は'K55', 'K41', 'その他'のいずれかでなければならない。
* 社員の平均給与は20以上でなければならない。

### 表明（assertion）

異なるリレーション間で定義される制約を**表明**によって記述する。
設計者の視点からの制約記述。

例：リレーション「社員」，「部門」を定義したとする。
「上司よりも高給をとっている社員がいてはいけない」という制約は２つのリレーション間を用いて表現される。

### トリガ（trigger）

ユーザのアプリケーションの視点からの制約。
> **ユーザ定義**とは？先にSQL触った方が良さそう。

あるリレーションの更新をきっかけに、他のリレーションに対して変更をするための仕掛けが**トリガ**である。

例：社員ー部門データベースがあるとする。
リレーション「社員」において、新入社員を挿入したり，辞める人を削除する際には、リレーション「部門」の部員数を増減する必要がある。


## データベーススキーマ

データベーススキーマ：リレーションスキーマに対し、さらに一貫性制約を課した不変な構造。

> リレーションスキーマ：リレーションの不変な構造。おそらく属性の直積を指しており、リレーションである部分集合を作成することをインスタンスと呼んでいる。
> データベーススキーマ：リレーションスキーマに一貫性制約を含めた不変な構造。

> 圏的スキーマ：リレーション間の不変な構造。圏的スキーマからインスタンスによってリレーションを作れる。
> ["Category Theory for Scientists (Old Version)"](https://doi.org/10.48550/arXiv.1302.6946)(Spivak, David I. 2013. p.110. Exercise 3.5.3.2)では図式だけでなく、言語によって一貫性制約を記述することでデータベーススキーマになっている様に思える。


# リレーショナル代数

**リレーショナル代数**：リレーショナルデータベースを操作するための演算。リレーションについて閉じている集合操作である。

* 集合論的な演算：和，差，共通部分，直積
* リレーショナルの演算：射影，選択，結合，商

これらのうち和，差，直積，射影，選択の5つの演算は独立であり、他の演算はこれらを用いて定義することができる。
また射影，選択，結合，商はドメインを用いて定義するため、リレーショナルらしい演算であると言える。

本章の参考文献：[石川 佳治, ”データベース　【４：リレーショナルデータモデル（２）】”](https://www.db.is.i.nagoya-u.ac.jp/~ishikawa/lectures/db19/04.pdf)

## 集合論論的な演算

以下の演算は、リレーションを単に集合として見なした演算である。

### 和集合

先ず、和集合を定義するため、和両立を定義する。

**和両立**：$R(A_1, \cdots, A_n), S(B_1, \cdots, B_m)$について、

* $n = m$：$R, S$の次数が等しい。
* $\forall i \in \{1,\cdots,n\} \; \rm{dom}(A_i) = \rm{dom}(B_i)$

**和集合**$\cup$：リレーション$R, S$が和両立とする。
$$R \cup S := \{ t | t \in R \lor s \in S \}$$

### 差集合

**差集合**：$$R \setminus S := \{ t | t \in R \land t \notin S \} = \{ t \in R | t \notin S \} \subset R$$

### 共通集合

**共通集合**：$$R \cap S := R \smallsetminus (R \smallsetminus S) = \{ t | t \in R \land t \in S \} \subset R,S$$

### 直積集合

**直積集合**：$$R \times S := \{ (r,s) | r \in R \land s \in S \}$$

## リレーショナルの演算

本項目では、$A=\{A_i\}_{i=1,\dots,n},B=\{B_i\}_{i=1,\dots,m},C=\{C_i\}_{i=1,\dots,k}$を属性の集合とする。

### 射影演算

$R(A_1, \cdots, A_n)$の全属性集合$A$の部分集合を$X=\{ A_{i_k} | \forall k \in \bf{N}, \; 1 \leq k_i \leq n \} \subset A$とする。

**$R$の$X$上の射影**：$$\sigma_{X}(R) \equiv R[X] := \{t[X] \, | \, t \in R\}$$

> 集合論の射影演算子$\pi$を用いて、$\sigma_X(R) := \prod_{A_i \in X} \pi_{A_i} (R) = \prod_{A_i \in X} \rm{dom}(A_i)$と記述できそう

### 選択演算

$\theta$を比較演算子とする。

$A_i, A_j$が$\theta-$**選択可能**：次の命題の真偽が定まる：$\forall t \in R, \; t[A_i] \: \theta \: t[A_j]$

$R(\cdots, A_i, \cdots, A_j, \cdots)$の$A_i$と$A_j$上の $\theta-$**選択**：$R$の要素のうち、$A_i \theta A_j$を満たすタプルの集合を返す。
$$\sigma_{A_i \theta A_j}(R) \equiv R[A_i \: \theta \: A_j] := \{ \, t \, | \, t \in R \land (t[A_i] \: \theta \: t[A_j]) \, \} \subset R$$


### 結合演算

#### 結合
$R(\cdots, A_i, \cdots)$と$S(\cdots, B_j, \cdots)$の$A_i$と$B_j$上の $\theta-$**結合** $\bowtie_{A_i \theta B_j}$：$R$と$S$の直積のうち、$A_i=B_j$を満たすタプルのみからなる集合を返す。
$$R \bowtie_{A_i \theta B_j}S \equiv R[A_i \: \theta \: B_j]S := \sigma_{A_i \theta B_j}(R \times S) = \{ (t,s) | t \in R \land u \in S \land t[A_i] \: \theta \: u[B_j] \} \subset R \times S$$

#### 等結合
**等結合**：比較演算子$\theta$に等号$=$を用いた結合：$R \bowtie_{A_i = B_j} S \equiv R[A_i = B_j]S$

等結合$R[A_i = B_j]S$で得られるリレーションは、各タプルの属性$A_i, B_j$が重複する。そこで自然な結合を定義する。

#### 自然結合
**自然結合**：結合の操作時に、重複する属性を除外しながら結合する演算。
<br>
$R(A_1, \cdots, A_n, B_1, \cdots, B_m), S(B_1, \cdots, B_m, C_1, \cdots, C_k)$をリレーションとする。
$$
R \bowtie S \equiv R*S 
:= \pi_{A_1,\cdots,A_n, B_1,\cdots,B_m, C_1,\cdots,C_k}(\sigma_{R[B]=S[B]} (R \times S))
$$

### 商演算

$R(A_1, \cdots, A_{n-m}, B_1, \cdots, B_m)$を$n$次の，$S(B_1, \cdots, B_m)$を$m$次のリレーションとする。

$R$を$S$で割った商：$R$の属性のうち、$S$にも属性として含まれているものを除く。
$$
R \div S 
:= \pi_{A_1, \cdots, A_n}(R) - \pi_{A_1, \cdots, A_n}((\pi_{A_1, \cdots, A_n}(R) \times S) - R)
= \{ t | t \in R[A_1, \cdots, A_{n-m}] \land \forall u \in S \, ( \, (t,u) \in R) \}
$$

Prop. $(R \times S) \div S = R$

## リレーショナル論理

集合論に基づいたリレーショナル代数とは別のデータ操作言語として、述語論理に基づいた**リレーショナル論理**なるものがあるらしい。

リレーショナル論理：
* タプルリレーショナル論理
* ドメインリレーショナル論理

３つの大系は問い合わせの記述能力に関して等価である（記述できること・できないことが同じ）。
逆に言うと、いずれもリレーショナルデータベースのデータ操作言語として取りこぼしが無い（リレーショナル完備である）。

# 正規化理論：更新時異常と無損失損失分解（以下、勉強中）

# 正規化理論：高次の正規化

# リレーショナルデータベース設計

## 実世界のモデル化

### 概念モデル

### 論理モデル

データベース構築：
1. 世界を
2. 実体ー関連モデル（E-Rモデル）

# データベース管理システム

# 質問処理の最適化

# トランザクション

# 障害時回復

# 同時実行制御

# オブジェクト指向データベース
